"use strict";(self.webpackChunkjules_website=self.webpackChunkjules_website||[]).push([[643],{4537:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return s},contentTitle:function(){return i},metadata:function(){return p},assets:function(){return c},toc:function(){return d},default:function(){return m}});var n=a(7462),o=a(3366),r=(a(7294),a(4137)),l=["components"],s={title:"Hijacking the Dereference Operators",authors:"jules"},i=void 0,p={permalink:"/home2/blog/2021/05/26/hijacking-the-dereference-operators",source:"@site/blog/2021-05-26-hijacking-the-dereference-operators.md",title:"Hijacking the Dereference Operators",description:"I often end up writting classes that wrap other classes or primitive types.",date:"2021-05-26T00:00:00.000Z",formattedDate:"May 26, 2021",tags:[],readingTime:2.33,truncated:!0,authors:[{name:"Jules Fouchy",title:"Cool developer & cool developer",url:"https://julesfouchy.github.io/home/",imageURL:"https://github.com/julesfouchy.png",key:"jules"}],prevItem:{title:"Unit Type-System",permalink:"/home2/blog/2021/05/28/unit-type-system"}},c={authorsImageUrls:[void 0]},d=[],u={toc:d};function m(e){var t=e.components,a=(0,o.Z)(e,l);return(0,r.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"I often end up writting classes that wrap other classes or primitive types."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"struct MyData {\n      float field1;\n      float field2;\n      float field3;\n      float field4;\n      float field5;\n\n      void do_something();\n};\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class MyDataWrapper {\npublic:\n      void do_something_else();\n\nprivate:\n      MyData _my_data;\n};\n")),(0,r.kt)("p",null,"And for a long time I was annoyed when needing to access the underlying wrapped class. At first I was writting one getter function for each method or field of the wrapped class that I still needed to access."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class MyDataWrapper {\npublic:\n      void do_something_else();\n      // -- Getters --\n      float field1() { return _my_data.field1; }\n      float field2() { return _my_data.field2; }\n      float field3() { return _my_data.field3; }\n      float field4() { return _my_data.field4; }\n      float field5() { return _my_data.field5; }\n      void do_something() { _my_data.do_something(); }\n      // -- Getters --\n\nprivate:\n      MyData _my_data;\n};\n")),(0,r.kt)("p",null,"But that was a lot of boilerplate code to write and I couldn't stand it. It get's especially annoying when you do some refactor or API change, because now you have to propagate the changes in two classes instead of one."),(0,r.kt)("p",null," So I moved to having only one getter function, typically called ",(0,r.kt)("em",{parentName:"p"},"get"),", that would return a reference to the whole wrapped class."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class MyDataWrapper {\npublic:\n     void do_something_else();\n     // -- Getters --\n     const MyData& get() const { return _my_data; }\n     // -- Getters --\n\nprivate:\n     MyData _my_data;\n};\n")),(0,r.kt)("p",null,"In my opinion this is already much better because the implementor of the wrapper class needs to write way less code, and doesn't need to maintain it when the wrapped class changes."),(0,r.kt)("p",null,"But the API isn't as nice anymore ! We moved from"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"my_data_wrapper.do_something();\n")),(0,r.kt)("p",null,"to"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"my_data_wrapper.get().do_something();\n")),(0,r.kt)("p",null,"Basically, no matter what I call my getter function, it is still too long of a name and clutters the code."),(0,r.kt)("p",null,"So here comes the ultimate solution : ",(0,r.kt)("strong",{parentName:"p"},"Overload the dereference operators")," ! This makes the API only one character longuer than the original solution, and doesn't require the implementor to write a lot of boilerplate code either ! The best of both worlds !"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"my_data_wrapper->do_something();\n")),(0,r.kt)("p",null,"The only downside I can think of is that the syntax can be confusing for people who are not used to this pattern ; but I swear that when you are used to it, this is the greatest thing ever !"),(0,r.kt)("p",null,"For reference, this is how you would overload the dereference operators :"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class MyDataWrapper {\npublic:\n      void do_something_else();\n      // -- Getters --\n      const MyData& operator* () const { return _my_data; }\n      const MyData* operator->() const { return &operator*(); } // Reuse the implementation of operator*\n      // -- Getters --\n\nprivate:\n      MyData _my_data;\n};\n")),(0,r.kt)("p",null,"You can see this pattern in action in the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/CoolLibs/Params/blob/main/src/Cool/Params/Params.h"},(0,r.kt)("em",{parentName:"a"},"Params")," module")," for example."),(0,r.kt)("p",null,"This is also used in ",(0,r.kt)("a",{parentName:"p",href:"https://en.cppreference.com/w/cpp/utility/optional"},"std::optional")," by the way !"))}m.isMDXComponent=!0}}]);